# -*- coding: utf-8 -*-
"""IS5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-NP9iaH_omGlCOXgz8fLDWt30G8MqryX
"""

p = 11
q = 29

n = p * q 

phi_of_n = (p - 1) * (q - 1)

import random

def get_gcd(x, y):
    while(y):
        x, y = y, x % y
    return x


def get_encryption_key(n, phi_of_n):
    lst = [i for i in range(1, n+1)]
    e_list = []
    for i in lst:
        if (1 < i) and (i < phi_of_n):
            gcd = get_gcd(i, n)
            gcd_phi = get_gcd(i, phi_of_n)
            if (gcd == 1) and (gcd_phi == 1):
                e_list.append(i)
    if len(e_list) == 1:
        return e_list[0]
    else:
        return e_list[random.randint(1, len(e_list)-1)]   


def get_decryption_key(e, phi_of_n):
    d_list = []
    for i in range(e * 25):
        if (e * i) % phi_of_n == 1:
            d_list.append(i)
    return d_list[random.randint(1, len(d_list) - 1)]



e = get_encryption_key(n, phi_of_n)
d = get_decryption_key(e, phi_of_n)

# to avoid key collision
while d == e:
    d = get_decryption_key(e, phi_of_n)

public_key = [e, n]  # [137, 319]
private_key = [d, n]  # [1633, 319]


#enc

import string
def text_to_digits(PT):
    pool = string.ascii_letters + string.punctuation + " "
    M = []
    for i in PT:
        M.append(pool.index(i))
    return M

def encrypt(M, public_key):
    return [(i ** public_key[0]) % public_key[1] for i in M]


#decry

def decrypt(CT, private_key):
    return [((i ** private_key[0]) % private_key[1]) for i in CT]